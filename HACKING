This is brief developer-oriented overview in Pachi structure.

Pachi is completely Go-specific (c.f. Fuego; though e.g. atari go support
should be easy to add), but fairly modular. It has been built with focus
on MonteCarlo-based play, but it can in principle be used for other
play engines as well.


Basic architecture
==================

Pachi consists of the following components:


  +------+    +--------+    +---------+
  | core | -- | engine | -- | playout |
  +------+    +--------+    +---------+
                     |        |
                  +-------------+
                  | aux library |
                  +-------------+

* "core" takes care of the program's lifetime, GTP interface and basic
  fast Go board implementation

	zzgo.c		global initialization and the main loop
	version.h	current version information
	debug.h		debugging infrastructure
	random.[ch]	fast random number generator
	gtp.[ch]	GTP protocol interface
	stone.[ch]	one board point coloring definition
	move.[ch]	one board move definition
	board.[ch]	board definition and basic interface

* "aux library" provides extra functions like static tactical evaluation
  and pattern matching; it is somewhat interwound with "core" component

	tactics.[ch]	extended interfaces for the go board
	mq.h		"move queue" data structure
	stats.h		"move statistics" data structure
	probdist.[ch]	"probability distribution" data structure
	ownermap.[ch]	simulation-based finalpos. "owner map" data structure
	pattern3.[ch]	fast 3x3 spatial pattern matcher
	pattern.[ch]	general multi-feature pattern matcher

* "engine" receives notifications about opponent moves and is asked
  to generate a move to play on given board

	engine.h	abstract engine interface
	random/		example "random move generator" engine
	replay/		example "playout move generator" engine
	montecarlo/	simple treeless Monte Carlo engine, quite bitrotten
	uct/		the main UCT-player engine, see below
	patternscan/	auxiliary engine for harvesting patterns from
				existing games

* "playout" policy is asked to generate moves to play during the Monte Carlo
  simulations, and to provide rough evaluation of moves feasibility for
  the engine

	playout.[ch]	abstract playout policy interface,
				Monte Carlo simulation execution
	playout/light	uniformly random playout policy
	playout/moggy	rule-based "Mogo-like" playout policy
	playout/elo	probdist-based "CrazyStone-like" playout policy

* Also, several ways of testing Pachi are provided:

	t-unit/		interface for writing unit-tests for specific
				functionality, mainly tactics
	t-play/		interface for testing performance by playing games
				against a fixed opponent (e.g. GNUGo)


UCT architecture
================

The UCT engine has non-trivial structure by itself:

  +-------------+    +-----+     +-------------------+
  | node policy | -- | UCT | --- | node prior-hinter |
  +-------------+    +-----+     +-------------------+
                        |           |
                   +---------+      |
                   | playout | -----'
                   +---------+

* "UCT" is the core of the engine

	uct.[ch]	engine initialization, public interface
	internal.h	internal state and data structures
	tree.[ch]	minimax move tree with success statistics
	walk.[ch]	filling the tree by walking it many times
				and running MC simulations from leaves

* "node prior-hinter" assigns newly created nodes preliminary success
  statistics ("prior values") to focus the search better

	prior.[ch]	variety of methods for setting the priors

* "node policy" mainly chooses the current node's child to descend
  through during the tree walk, based on the already recorded statistics;
  it must balance exploration and exploitation well during the selection

	policy/ucb1	the old-school original simple policy
	policy/ucb1amaf	the AMAF/RAVE-based policy gathering statistics rapidly


Board Implementation
====================

The infrastructure is optimized for speed to make it well suited
for bruteforce engines, however tradeoffs are made to make it useful
for heavier MonteCarlo playouts as well (e.g. real liberties are
tracked instead of pseudoliberties). If you are looking for raw
light playout speed, libEGO is better choice.

Ruleset
-------

While the Pachi engines generally play according to Chinese rules,
internally, Pachi uses Tromp-Taylor rules because they are simple,
fast and universal; they are very close to the New Zealand rules.
That means, it simply counts the number of stones and one-point eyes
of each color on the board, plus komi and handicap correction.

Tromp-Taylor rules also mean that multi-stone suicide is allowed! If you
do not like that (basically if you want to pretend it plays according
to Chinese rules), you need to rule that out in your engine, currently.
The provided engines DO avoid multi-stone suicide (but the UCT engine
will never play it itself).

Tromp-Taylor rules have positional superko; the board implementation
will set a flag if it is violated, but play the move anyway. You need
to enforce the superko rule in your engine.


GTP Implementation
==================

...is a very sad hack. ENSURE that only trusted parties talk to Pachi's
GTP interface, as it is totally non-resilient to any kind of overflow
or bad input attacks and allowing arbitrary input to be entered within
is a major security hole. Yes, this needs to be cleaned up. Also, currently
engines cannot plug in their own commands and there is no GoGui interface.

Pachi supports only few GTP commands now. Most importantly, it does not
support the undo command and it does not support time-keeping.
The final_status_list command requires engine support.


General Pattern Matcher
=======================

Pachi has in-development general pattern matcher that can match various
sets of features (spatial and others), inspired by the CrazyStone pattern
model. Please see pattern.h for detailed description of the pattern concept
and recognized features.

To harvest patterns, use 'zzgo -e patternscan' (see patternscan/patternscan.c
for available options).  The output of the pattern scanner are two data
structures: The matched patterns

	(feature1:payload feature2:payload ...)

and spatial dictionary. "Spatial" feature represents a particular
configuration of stones in a circle around the move-to-play; each
configuration has its own record in the dictionary and the spatial
feature references only the id in the dictionary; so you need to keep
both the patterns and the "patterns.spat" file.  Normally, 'patternscan'
will only match already existing dictionary entries, but you
can pass it "gen_spat_dict" so that it appends all newly found spatial
features to the dictionary - use "spat_threshold" to limit recording
only to frequently occuring spatial features; to start the dictionary
from scratch, simply remove any existing "patterns.spat" file.

There are few pre-made scripts to make the initialization of the pattern
matcher easy:

* pattern_byplayer.sh: Sorts out patterns from given SGF collection by
  player names, one player per file in a dedicated directory. This is
  useful if you want to use the patterns to e.g. recognize games of a
  player by characteristic patterns.

* pattern_gather.sh: Gathers patterns indiscriminately from given SGF
  collection, capping the number of kept spatial patterns. This is useful
  to gather general pattern statistics while keeping the amount of spatial
  patterns manageable.

* pattern_mm.sh: Combines our scripts and the MM tool (see below),
  producing gamma values for harvested patterns.

* pattern_spatial_show.sh ID: Shows spatial pattern of given id in 2D plane.

These extra scripts are used internally by pattern_mm:

* pattern_enumerate.pl: Numbers all patterns and possible payloads and
  produces numeric versions of patterns and a mapping file.

* pattern_mminput.pl: Takes output of pattern_enumerate.pl and converts
  it to a format that can be directly pipelined to the MM tool (see below).

Minorization-majorization (CrazyStone patterns)
-----------------------------------------------

The pattern harvester can be used together with the MM tool by Remi Coulom:

	http://remi.coulom.free.fr/Amsterdam2007/mm.tar.bz2

This tool will compute relative strength of individual features for teaming
them up and using the outcoming probability distribution for generating moves.
There is a script that will take you from SGF game collection to gamma values
in single shot - "pattern_mm.sh".

The resulting "patterns.gamma" file contains mapping from feature instances
to gamma floats, representing the features strength; note that it is totally
meaningless without the accompanying "patterns.spat" file generated by the
pattern_gather script. To make Pachi use the gamma values for tree bias and
in MC playouts, use the "elo" playout policy - but note that it's still in
heavy development.
